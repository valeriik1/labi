#include <iostream>
#include <string>
#include <climits>
#include <vector>
using namespace std;


int main() {

    string offer;
    cout << "Введите предложение: "; //вводим предложение
    getline(cin, offer); // записываем введенное предложение

    int minlength = offer.size(), maxlength = 0; // вводим переменные мин и макс длины и мин длине присваиваем длину самого предложения
    vector<string> minword, maxword; // вводим вектора в которые будут записываться короткие и длинные слова
    string word = ""; // инициализация пустой строки

    // перебираем символы в строке
    for (size_t i = 0; i < offer.size(); ++i) { // добавляем счетчик с значением 0; пока счетчик меньше длины строки, то он увеличивается на 1 после каждой итерации
        unsigned char c = static_cast<unsigned char>(offer[i]); // внутри цикла символ offer[i] приводится к типу unsigned char с помощью static_cast<unsigned char>(offer[i]); программа выводит каждый символ строки вместе с его позицией и кодом символа
        int c_ascii = static_cast<int>(c); // приводим символы к типу int, чтобы получить его аски код

        if (isspace(c) || i == offer.size() - 1) { // если на пути встречается пробел или i равна длине строки на единицу меньше 
            if (!word.empty()) { // проверяем является ли строка не пустой
                size_t wordlength = word.length(); // метод получения длины строки
                cout << word << " " << wordlength << "\n"; // выводим слово и его длину

                if (wordlength <= minlength) { // сравниваем встречается ли слово одинаковой длины либо меньше, чем то, что есть сейчас
                    if (wordlength < minlength) { // но если проверяемое новое слово меньше того, которое мы только что записали, то записываем то, которое в итоге меньше
                        minword.clear(); // если перезаписываем слово, то чистим все внутри minword
                        minlength = wordlength; // минимальнач длина слова равна длине самого слова
                    }
                    minword.push_back(word); // добавление слова в вектор
                }

                if (wordlength >= maxlength) { // сравниваем встречается ли слово одинаковой длины либо больше, чем то, что есть сейчас
                    if (wordlength > maxlength) { // но если проверяемое новое слово больше того, которое мы только что записали, то записываем то, которое в итоге больше
                        maxword.clear(); // если перезаписываем слово, то чистим все внутри maxword
                        maxlength = wordlength; // максимальная длина слова равна длине самого слова
                    }
                    maxword.push_back(word); // добавление слова в вектор
                }

                word.clear(); // строка word очищается, чтобы подготовить её для следующего ввода
            }
        }
        else {
            if (isalpha(c) || (192 <= c_ascii && c_ascii <= 255) || c_ascii == 168 || c_ascii == 184) // проверяет, является ли символ частью алфавита
                word += offer[i]; // если символ является буквой, то он записывается к текущему слову word
        }
    }

    // выводим слова и их длины
    cout << "Самое короткое слово состоит из " << minlength << " символов.\n";
    cout << "Слова с мин. длиной: ";
    for (const string & c : minword) { // приходит к каждому элементу minword
        cout << c << " "; // выводит каждый элемент вектора на экран через пробел
    }
    cout << endl;

    cout << "Самое длинное слово состоит из " << maxlength << " символов.\n";
    cout << "Слова с макс. длиной: ";
    for (const string& c : maxword) { // приходит к каждому элементу maxword
        cout << c << " "; // выводит каждый элемент вектора на экран через пробел
    }
    cout << endl;

    return 0;
}